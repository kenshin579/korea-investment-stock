#!/usr/bin/env python3
"""
ÌÜµÍ≥Ñ ÏãúÍ∞ÅÌôî ÏòàÏ†ú (Plotly ÎèÖÎ¶ΩÌòï Î≤ÑÏ†Ñ)
Ï†ÄÏû•Îêú ÌÜµÍ≥Ñ ÌååÏùºÏùÑ ÏùΩÏñ¥ÏÑú Ïù∏ÌÑ∞ÎûôÌã∞Î∏åÌïú Í∑∏ÎûòÌîÑÎ•º ÏÉùÏÑ±Ìï©ÎãàÎã§.

Ïù¥ ÏòàÏ†úÎäî Í≥†Í∏â ÏÇ¨Ïö©ÏûêÎ•º ÏúÑÌïú ÏÉÅÏÑ∏Ìïú Íµ¨ÌòÑÏùÑ Î≥¥Ïó¨Ï§çÎãàÎã§.
ÏùºÎ∞òÏ†ÅÏù∏ ÏÇ¨Ïö©ÏùÄ visualization_integrated_example.pyÎ•º Ï∞∏Í≥†ÌïòÏÑ∏Ïöî.

ÌäπÏßï:
- Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÏßÄÏõê
- Ïù∏ÌÑ∞ÎûôÌã∞Î∏å ÎåÄÏãúÎ≥¥Îìú
- Îã§ÏñëÌïú ÌÜµÍ≥Ñ ÏßÄÌëú ÏãúÍ∞ÅÌôî
- HTML ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ÏßÄÏõê
- Ìå®ÌÇ§ÏßÄ ÏóÜÏù¥ ÎèÖÎ¶ΩÏ†ÅÏúºÎ°ú Ïã§Ìñâ Í∞ÄÎä•
"""

import json
import gzip
import time
from pathlib import Path
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
import pandas as pd
import numpy as np

# Plotly imports
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.express as px
import plotly.io as pio

# Korea Investment Stock imports
import sys
import os
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from korea_investment_stock.monitoring import get_stats_manager


class PlotlyStatsVisualizer:
    """PlotlyÎ•º ÏÇ¨Ïö©Ìïú ÌÜµÍ≥Ñ ÏãúÍ∞ÅÌôî ÌÅ¥ÎûòÏä§"""
    
    def __init__(self, stats_dir: str = "logs/integrated_stats"):
        self.stats_dir = Path(stats_dir)
        self.history_data = []
        self.latest_stats = None
        self.dashboard = None
        self.stats_manager = get_stats_manager()
        
    def load_history_data(self, filename: str = "stats_history.jsonl.gz") -> List[Dict]:
        """ÏïïÏ∂ïÎêú ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞ Î°úÎìú"""
        filepath = self.stats_dir / filename
        
        if not filepath.exists():
            print(f"ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: {filepath}")
            return []
        
        # StatsManagerÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Î°úÎìú
        data = self.stats_manager.load_stats(filepath, format='jsonl')
        
        self.history_data = data
        print(f"‚úÖ {len(data)}Í∞úÏùò ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å")
        return data
    
    def load_latest_stats(self) -> Dict:
        """Í∞ÄÏû• ÏµúÍ∑º ÌÜµÍ≥Ñ ÌååÏùº Î°úÎìú"""
        # JSON ÌååÏùº ÏßÅÏ†ë Í≤ÄÏÉâ
        json_files = list(self.stats_dir.glob("stats_*.json"))
        
        if not json_files:
            print("JSON ÌÜµÍ≥Ñ ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
            # JSONL ÌååÏùºÏóêÏÑú ÏµúÏã† Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
            if self.history_data:
                self.latest_stats = self.history_data[-1]
                print(f"‚úÖ JSONLÏóêÏÑú ÏµúÏã† ÌÜµÍ≥Ñ Î°úÎìú")
                return self.latest_stats
            return {}
        
        # Í∞ÄÏû• ÏµúÍ∑º ÌååÏùº ÏÑ†ÌÉù
        latest_file = max(json_files, key=lambda f: f.stat().st_mtime)
        
        with open(latest_file, 'r', encoding='utf-8') as f:
            self.latest_stats = json.load(f)
            
        print(f"‚úÖ ÏµúÏã† ÌÜµÍ≥Ñ ÌååÏùº Î°úÎìú: {latest_file.name}")
        return self.latest_stats
    
    def create_realtime_dashboard(self, update_interval: int = 5000):
        """Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏Í∞Ä Í∞ÄÎä•Ìïú ÎåÄÏãúÎ≥¥Îìú ÏÉùÏÑ±
        
        Args:
            update_interval: ÏóÖÎç∞Ïù¥Ìä∏ Í∞ÑÍ≤© (Î∞ÄÎ¶¨Ï¥à)
        """
        if not self.history_data:
            print("ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.")
            return None
        
        # Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ
        df = self._prepare_dataframe()
        
        # Î†àÏù¥ÏïÑÏõÉ ÏÉùÏÑ± (3x2 Í∑∏Î¶¨Îìú)
        fig = make_subplots(
            rows=3, cols=2,
            subplot_titles=(
                'üìà API Ìò∏Ï∂ú Î∞è ÏóêÎü¨ Ï∂îÏù¥',
                'üìä ÏãúÏä§ÌÖú Ìó¨Ïä§ ÏÉÅÌÉú',
                'üíæ Ï∫êÏãú Ìö®Ïú®ÏÑ±',
                '‚ö° Rate Limiter ÏÑ±Îä•',
                'üîÑ Î∞∞Ïπò Ï≤òÎ¶¨ Ìö®Ïú®',
                'üö® ÏóêÎü¨ ÌÉÄÏûÖ Î∂ÑÌè¨'
            ),
            specs=[
                [{"secondary_y": True}, {"type": "indicator"}],
                [{"secondary_y": False}, {"secondary_y": True}],
                [{"secondary_y": False}, {"type": "pie"}]
            ],
            vertical_spacing=0.1,
            horizontal_spacing=0.12,
            row_heights=[0.35, 0.35, 0.3]
        )
        
        # 1. API Ìò∏Ï∂ú Ï∂îÏù¥
        self._add_api_calls_trace(fig, df, row=1, col=1)
        
        # 2. ÏãúÏä§ÌÖú Ìó¨Ïä§ Ïù∏ÎîîÏºÄÏù¥ÌÑ∞
        self._add_health_indicator(fig, row=1, col=2)
        
        # 3. Ï∫êÏãú Ìö®Ïú®ÏÑ±
        self._add_cache_efficiency_trace(fig, df, row=2, col=1)
        
        # 4. Rate Limiter ÏÑ±Îä•
        self._add_rate_limiter_performance(fig, df, row=2, col=2)
        
        # 5. Î∞∞Ïπò Ï≤òÎ¶¨ Ìö®Ïú®
        self._add_batch_processing_trace(fig, df, row=3, col=1)
        
        # 6. ÏóêÎü¨ ÌÉÄÏûÖ Î∂ÑÌè¨
        self._add_error_distribution(fig, row=3, col=2)
        
        # Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï
        fig.update_layout(
            title={
                'text': 'ÌïúÍµ≠Ìà¨ÏûêÏ¶ùÍ∂å API Ïã§ÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ ÎåÄÏãúÎ≥¥Îìú',
                'font': {'size': 26, 'color': '#2C3E50', 'family': 'Arial Black'},
                'x': 0.5,
                'xanchor': 'center'
            },
            height=1000,
            showlegend=True,
            template='plotly_white',
            hovermode='x unified',
            updatemenus=[{
                'type': 'buttons',
                'direction': 'left',
                'buttons': [
                    {
                        'label': '‚ñ∂ Ïû¨ÏÉù',
                        'method': 'animate',
                        'args': [None, {
                            'frame': {'duration': update_interval, 'redraw': True},
                            'fromcurrent': True
                        }]
                    },
                    {
                        'label': '‚è∏ ÏùºÏãúÏ†ïÏßÄ',
                        'method': 'animate',
                        'args': [[None], {
                            'frame': {'duration': 0, 'redraw': False},
                            'mode': 'immediate',
                            'transition': {'duration': 0}
                        }]
                    }
                ],
                'pad': {'r': 10, 't': 60},
                'showactive': False,
                'x': 0.1,
                'xanchor': 'right',
                'y': 1.15,
                'yanchor': 'top'
            }]
        )
        
        # Ï∂ï Ìè¨Îß∑ ÏóÖÎç∞Ïù¥Ìä∏
        for row in [2, 3]:
            for col in [1, 2]:
                if row == 3 and col == 2:
                    continue  # pie chart
                fig.update_xaxes(
                    title_text="ÏãúÍ∞Ñ",
                    tickformat="%H:%M:%S",
                    row=row, col=col
                )
        
        self.dashboard = fig
        return fig
    
    def _prepare_dataframe(self) -> pd.DataFrame:
        """ÌûàÏä§ÌÜ†Î¶¨ Îç∞Ïù¥ÌÑ∞Î•º DataFrameÏúºÎ°ú Î≥ÄÌôò"""
        records = []
        
        for stat in self.history_data:
            # Í∏∞Î≥∏ Í∞íÎì§Î°ú record Ï¥àÍ∏∞Ìôî
            record = {
                'timestamp': datetime.now(),
                'total_api_calls': 0,
                'total_errors': 0,
                'error_rate': 0,
                'cache_hit_rate': 0,
                'api_calls_saved': 0,
                'system_health': 'UNKNOWN',
                'max_tps': 0
            }
            
            # timestamp Ï≤òÎ¶¨
            if 'timestamp' in stat:
                try:
                    if isinstance(stat['timestamp'], str):
                        record['timestamp'] = datetime.fromisoformat(stat['timestamp'])
                    else:
                        record['timestamp'] = stat['timestamp']
                except:
                    pass
            
            # summary Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨
            if 'summary' in stat and isinstance(stat['summary'], dict):
                summary = stat['summary']
                record.update({
                    'total_api_calls': summary.get('total_api_calls', 0),
                    'total_errors': summary.get('total_errors', 0),
                    'error_rate': summary.get('overall_error_rate', 0) * 100,
                    'cache_hit_rate': summary.get('cache_hit_rate', 0) * 100,
                    'api_calls_saved': summary.get('api_calls_saved', 0),
                    'system_health': summary.get('system_health', 'UNKNOWN'),
                    'max_tps': summary.get('max_tps', 0)
                })
            
            # modules Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏùÑ Í≤ΩÏö∞ÏóêÎßå Ï≤òÎ¶¨
            if 'modules' in stat and isinstance(stat['modules'], dict):
                # Rate Limiter Îç∞Ïù¥ÌÑ∞
                if 'rate_limiter' in stat['modules']:
                    rl = stat['modules']['rate_limiter']
                    record['rl_total_calls'] = rl.get('total_calls', 0)
                    record['rl_error_count'] = rl.get('error_count', 0)
                    record['rl_avg_wait_time'] = rl.get('avg_wait_time', 0)
                    record['rl_max_calls_per_second'] = rl.get('max_calls_per_second', 0)
                    
                    # config Ï†ïÎ≥¥
                    if 'config' in rl:
                        record['rl_nominal_max_calls'] = rl['config'].get('nominal_max_calls', 15)
                        record['rl_effective_max_calls'] = rl['config'].get('effective_max_calls', 12)
                
                # Batch Controller Îç∞Ïù¥ÌÑ∞
                if 'batch_controller' in stat['modules']:
                    bc = stat['modules']['batch_controller']
                    record['bc_current_batch_size'] = bc.get('current_batch_size', 0)
                    record['bc_total_batches'] = bc.get('total_batches', 0)
                
                # Error Recovery Îç∞Ïù¥ÌÑ∞
                if 'error_recovery' in stat['modules']:
                    er = stat['modules']['error_recovery']
                    record['er_total_errors'] = er.get('total_errors', 0)
                    if 'by_type' in er:
                        record['error_types'] = er['by_type']
            
            # Í∏∞Ï°¥ ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ ÌòïÏãù (modulesÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞) Ï≤òÎ¶¨
            elif 'rate_limiter' in stat:
                # ÏßÅÏ†ë rate_limiter Îç∞Ïù¥ÌÑ∞Ïóê Ï†ëÍ∑º
                rl = stat.get('rate_limiter', {})
                if isinstance(rl, dict):
                    record['rl_total_calls'] = rl.get('total_calls', 0)
                    record['rl_error_count'] = rl.get('error_count', 0)
                    record['rl_avg_wait_time'] = rl.get('avg_wait_time', 0)
                    record['rl_max_calls_per_second'] = rl.get('max_calls_per_second', 0)
                    record['total_api_calls'] = rl.get('total_calls', 0)
                    record['total_errors'] = rl.get('error_count', 0)
                    
                    if rl.get('total_calls', 0) > 0:
                        record['error_rate'] = (rl.get('error_count', 0) / rl['total_calls']) * 100
            
            records.append(record)
        
        # DataFrame ÏÉùÏÑ± Î∞è Ï†ïÎ†¨
        df = pd.DataFrame(records)
        if not df.empty and 'timestamp' in df.columns:
            df = df.sort_values('timestamp').reset_index(drop=True)
        
        return df
    
    def _add_api_calls_trace(self, fig, df, row, col):
        """API Ìò∏Ï∂ú Ï∂îÏù¥ Ï∂îÍ∞Ä"""
        # API Ìò∏Ï∂ú Ïàò (Area chart)
        fig.add_trace(
            go.Scatter(
                x=df['timestamp'],
                y=df['total_api_calls'],
                name='API Ìò∏Ï∂ú',
                line=dict(color='#3498DB', width=3),
                fill='tozeroy',
                fillcolor='rgba(52, 152, 219, 0.2)',
                mode='lines',
                hovertemplate='API Ìò∏Ï∂ú: %{y:,}<extra></extra>'
            ),
            row=row, col=col, secondary_y=False
        )
        
        # ÏóêÎü¨ Ïàò (Î≥¥Ï°∞ YÏ∂ï)
        fig.add_trace(
            go.Scatter(
                x=df['timestamp'],
                y=df['total_errors'],
                name='ÏóêÎü¨',
                line=dict(color='#E74C3C', width=2),
                mode='lines+markers',
                marker=dict(size=6, symbol='x'),
                hovertemplate='ÏóêÎü¨: %{y}<extra></extra>'
            ),
            row=row, col=col, secondary_y=True
        )
        
        # Ï∂ï Î†àÏù¥Î∏î
        fig.update_yaxes(title_text="API Ìò∏Ï∂ú Ïàò", secondary_y=False, row=row, col=col)
        fig.update_yaxes(title_text="ÏóêÎü¨ Ïàò", secondary_y=True, row=row, col=col)
    
    def _add_health_indicator(self, fig, row, col):
        """ÏãúÏä§ÌÖú Ìó¨Ïä§ Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ Ï∂îÍ∞Ä"""
        if not self.latest_stats:
            return
        
        summary = self.latest_stats.get('summary', {})
        health = summary.get('system_health', 'UNKNOWN')
        error_rate = summary.get('overall_error_rate', 0) * 100
        
        # ÏÉâÏÉÅ Îß§Ìïë
        color_map = {
            'HEALTHY': '#2ECC71',
            'WARNING': '#F39C12',
            'CRITICAL': '#E74C3C',
            'UNKNOWN': '#95A5A6'
        }
        
        fig.add_trace(
            go.Indicator(
                mode="gauge+number+delta",
                value=100 - error_rate,  # Í±¥Í∞ïÎèÑ (100 - ÏóêÎü¨Ïú®)
                title={'text': f"ÏãúÏä§ÌÖú ÏÉÅÌÉú: {health}"},
                delta={'reference': 95},  # 95% Ïù¥ÏÉÅÏù¥ Î™©Ìëú
                gauge={
                    'axis': {'range': [0, 100]},
                    'bar': {'color': color_map.get(health, '#95A5A6')},
                    'steps': [
                        {'range': [0, 95], 'color': "lightgray"},
                        {'range': [95, 99], 'color': "gray"}
                    ],
                    'threshold': {
                        'line': {'color': "red", 'width': 4},
                        'thickness': 0.75,
                        'value': 99
                    }
                },
                domain={'row': row-1, 'column': col-1}
            ),
            row=row, col=col
        )
    
    def _add_cache_efficiency_trace(self, fig, df, row, col):
        """Ï∫êÏãú Ìö®Ïú®ÏÑ± ÏãúÍ∞ÅÌôî"""
        # Ï∫êÏãú Ï†ÅÏ§ëÎ•†Í≥º Ï†àÍ∞êÎêú API Ìò∏Ï∂ú ÏàòÎ•º Ìï®Íªò ÌëúÏãú
        fig.add_trace(
            go.Scatter(
                x=df['timestamp'],
                y=df['cache_hit_rate'],
                name='Ï∫êÏãú Ï†ÅÏ§ëÎ•† (%)',
                line=dict(color='#2ECC71', width=3),
                mode='lines+markers',
                marker=dict(size=8),
                yaxis='y',
                hovertemplate='Ï∫êÏãú Ï†ÅÏ§ëÎ•†: %{y:.1f}%<extra></extra>'
            ),
            row=row, col=col
        )
        
        # Ï†àÍ∞êÎêú API Ìò∏Ï∂ú Ïàò (ÎàÑÏ†Å)
        df['api_calls_saved_cumsum'] = df['api_calls_saved'].cumsum()
        fig.add_trace(
            go.Scatter(
                x=df['timestamp'],
                y=df['api_calls_saved_cumsum'],
                name='ÎàÑÏ†Å Ï†àÍ∞ê Ìò∏Ï∂ú',
                line=dict(color='#16A085', width=2, dash='dash'),
                mode='lines',
                yaxis='y2',
                hovertemplate='ÎàÑÏ†Å Ï†àÍ∞ê: %{y:,}<extra></extra>'
            ),
            row=row, col=col
        )
        
        fig.update_yaxes(title_text="Ï∫êÏãú Ï†ÅÏ§ëÎ•† (%)", row=row, col=col)
    
    def _add_rate_limiter_performance(self, fig, df, row, col):
        """Rate Limiter ÏÑ±Îä• ÏßÄÌëú"""
        if 'rl_max_calls_per_second' in df.columns:
            # Ïã§Ï†ú TPS vs Ï†úÌïúÍ∞í
            fig.add_trace(
                go.Scatter(
                    x=df['timestamp'],
                    y=df['rl_max_calls_per_second'],
                    name='Ïã§Ï†ú TPS',
                    line=dict(color='#F39C12', width=3),
                    mode='lines+markers',
                    hovertemplate='Ïã§Ï†ú TPS: %{y}<extra></extra>'
                ),
                row=row, col=col, secondary_y=False
            )
            
            # Ï†úÌïúÍ∞í ÎùºÏù∏
            if 'rl_effective_max_calls' in df.columns:
                fig.add_trace(
                    go.Scatter(
                        x=df['timestamp'],
                        y=df['rl_effective_max_calls'],
                        name='TPS Ï†úÌïú',
                        line=dict(color='red', width=2, dash='dash'),
                        mode='lines',
                        hovertemplate='Ï†úÌïú: %{y}<extra></extra>'
                    ),
                    row=row, col=col, secondary_y=False
                )
            
            # ÌèâÍ∑† ÎåÄÍ∏∞ ÏãúÍ∞Ñ
            fig.add_trace(
                go.Bar(
                    x=df['timestamp'],
                    y=df['rl_avg_wait_time'] * 1000,  # msÎ°ú Î≥ÄÌôò
                    name='ÌèâÍ∑† ÎåÄÍ∏∞ ÏãúÍ∞Ñ (ms)',
                    marker=dict(color='#E67E22', opacity=0.5),
                    yaxis='y2',
                    hovertemplate='ÎåÄÍ∏∞: %{y:.1f}ms<extra></extra>'
                ),
                row=row, col=col, secondary_y=True
            )
            
            fig.update_yaxes(title_text="TPS", secondary_y=False, row=row, col=col)
            fig.update_yaxes(title_text="ÎåÄÍ∏∞ ÏãúÍ∞Ñ (ms)", secondary_y=True, row=row, col=col)
    
    def _add_batch_processing_trace(self, fig, df, row, col):
        """Î∞∞Ïπò Ï≤òÎ¶¨ Ìö®Ïú®ÏÑ±"""
        if 'bc_current_batch_size' in df.columns:
            # Î∞∞Ïπò ÌÅ¨Í∏∞ Î≥ÄÌôî
            fig.add_trace(
                go.Scatter(
                    x=df['timestamp'],
                    y=df['bc_current_batch_size'],
                    name='Î∞∞Ïπò ÌÅ¨Í∏∞',
                    line=dict(color='#9B59B6', width=3),
                    mode='lines+markers+text',
                    text=df['bc_current_batch_size'],
                    textposition='top center',
                    hovertemplate='Î∞∞Ïπò ÌÅ¨Í∏∞: %{y}<extra></extra>'
                ),
                row=row, col=col
            )
            
            fig.update_yaxes(title_text="Î∞∞Ïπò ÌÅ¨Í∏∞", row=row, col=col)
            
            # ÏóêÎü¨Ïú®Ïóê Îî∞Î•∏ Î∞∞Í≤ΩÏÉâ Ï∂îÍ∞Ä
            for i in range(len(df)-1):
                if df['error_rate'].iloc[i] > 5:
                    color = 'rgba(231, 76, 60, 0.1)'  # Îπ®Í∞ï
                elif df['error_rate'].iloc[i] > 1:
                    color = 'rgba(243, 156, 18, 0.1)'  # Ï£ºÌô©
                else:
                    color = 'rgba(46, 204, 113, 0.1)'  # Ï¥àÎ°ù
                
                fig.add_vrect(
                    x0=df['timestamp'].iloc[i],
                    x1=df['timestamp'].iloc[i+1] if i+1 < len(df) else df['timestamp'].iloc[i],
                    fillcolor=color,
                    layer="below",
                    line_width=0,
                    row=row, col=col
                )
    
    def _add_error_distribution(self, fig, row, col):
        """ÏóêÎü¨ ÌÉÄÏûÖ Î∂ÑÌè¨ (ÌååÏù¥ Ï∞®Ìä∏)"""
        if self.latest_stats and 'modules' in self.latest_stats:
            if 'error_recovery' in self.latest_stats['modules']:
                er = self.latest_stats['modules']['error_recovery']
                if 'by_type' in er:
                    error_types = er['by_type']
                    
                    labels = list(error_types.keys())
                    values = list(error_types.values())
                    
                    fig.add_trace(
                        go.Pie(
                            labels=labels,
                            values=values,
                            hole=0.4,
                            marker=dict(
                                colors=px.colors.qualitative.Set3[:len(labels)]
                            ),
                            textinfo='label+percent',
                            hovertemplate='%{label}: %{value}Í±¥<br>%{percent}<extra></extra>'
                        ),
                        row=row, col=col
                    )
    
    def create_summary_card(self) -> go.Figure:
        """Ìñ•ÏÉÅÎêú ÏöîÏïΩ Ï†ïÎ≥¥ Ïπ¥Îìú"""
        if not self.latest_stats:
            return None
        
        summary = self.latest_stats.get('summary', {})
        modules = self.latest_stats.get('modules', {})
        
        # ÏßÄÌëú Ïπ¥Îìú ÏÉùÏÑ±
        fig = make_subplots(
            rows=2, cols=4,
            specs=[
                [{"type": "indicator"}, {"type": "indicator"}, {"type": "indicator"}, {"type": "indicator"}],
                [{"type": "indicator"}, {"type": "indicator"}, {"type": "indicator"}, {"type": "indicator"}]
            ]
        )
        
        # Ï≤´ Î≤àÏß∏ Ìñâ
        indicators = [
            {
                'value': 100 - summary.get('overall_error_rate', 0) * 100,  # Í±¥Í∞ïÎèÑ Ï†êÏàò
                'mode': 'number+gauge',
                'title': {'text': f"ÏãúÏä§ÌÖú ÏÉÅÌÉú: {summary.get('system_health', 'UNKNOWN')}"},
                'number': {'suffix': '%', 'font': {'color': self._get_health_color(summary.get('system_health', 'UNKNOWN'))}},
                'gauge': {
                    'axis': {'range': [0, 100]},
                    'bar': {'color': self._get_health_color(summary.get('system_health', 'UNKNOWN'))},
                    'threshold': {
                        'line': {'color': "red", 'width': 4},
                        'thickness': 0.75,
                        'value': 95
                    }
                },
                'row': 1, 'col': 1
            },
            {
                'value': summary.get('total_api_calls', 0),
                'mode': 'number',
                'title': {'text': 'API Ìò∏Ï∂ú'},
                'number': {'font': {'color': '#3498DB'}},
                'row': 1, 'col': 2
            },
            {
                'value': summary.get('overall_error_rate', 0) * 100,
                'mode': 'number+gauge',
                'title': {'text': 'ÏóêÎü¨Ïú®'},
                'number': {'suffix': '%', 'font': {'color': '#E74C3C'}},
                'gauge': {'axis': {'range': [0, 10]}},
                'row': 1, 'col': 3
            },
            {
                'value': summary.get('cache_hit_rate', 0) * 100,
                'mode': 'number+gauge',
                'title': {'text': 'Ï∫êÏãú Ï†ÅÏ§ëÎ•†'},
                'number': {'suffix': '%', 'font': {'color': '#2ECC71'}},
                'gauge': {'axis': {'range': [0, 100]}},
                'row': 1, 'col': 4
            }
        ]
        
        # Îëê Î≤àÏß∏ Ìñâ (Rate Limiter ÌÜµÍ≥Ñ)
        if 'rate_limiter' in modules:
            rl = modules['rate_limiter']
            indicators.extend([
                {
                    'value': rl.get('max_calls_per_second', 0),
                    'mode': 'number',
                    'title': {'text': 'ÏµúÎåÄ TPS'},
                    'number': {'font': {'color': '#F39C12'}},
                    'row': 2, 'col': 1
                },
                {
                    'value': rl.get('avg_wait_time', 0) * 1000,
                    'mode': 'number',
                    'title': {'text': 'ÌèâÍ∑† ÎåÄÍ∏∞ÏãúÍ∞Ñ'},
                    'number': {'suffix': 'ms', 'font': {'color': '#E67E22'}},
                    'row': 2, 'col': 2
                },
                {
                    'value': summary.get('api_calls_saved', 0),
                    'mode': 'number',
                    'title': {'text': 'Ï†àÍ∞êÎêú Ìò∏Ï∂ú'},
                    'number': {'font': {'color': '#16A085'}},
                    'row': 2, 'col': 3
                },
                {
                    'value': modules.get('batch_controller', {}).get('current_batch_size', 0),
                    'mode': 'number',
                    'title': {'text': 'ÌôúÏÑ± Î∞∞Ïπò'},
                    'number': {'font': {'color': '#9B59B6'}},
                    'row': 2, 'col': 4
                }
            ])
        
        # Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ Ï∂îÍ∞Ä
        for ind in indicators:
            fig.add_trace(
                go.Indicator(
                    value=ind['value'],
                    mode=ind.get('mode', 'number'),
                    title=ind.get('title', {}),
                    number=ind.get('number', {}),
                    gauge=ind.get('gauge', {}),
                ),
                row=ind['row'], col=ind['col']
            )
        
        fig.update_layout(
            title={
                'text': "ÏãúÏä§ÌÖú ÌòÑÌô© ÏöîÏïΩ ÎåÄÏãúÎ≥¥Îìú",
                'font': {'size': 20},
                'x': 0.5,
                'xanchor': 'center'
            },
            height=400,
            showlegend=False,
            margin=dict(l=20, r=20, t=60, b=20)
        )
        
        return fig
    
    def _get_health_color(self, health: str) -> str:
        """ÏãúÏä§ÌÖú ÏÉÅÌÉúÏóê Îî∞Î•∏ ÏÉâÏÉÅ Î∞òÌôò"""
        colors = {
            'HEALTHY': '#2ECC71',
            'WARNING': '#F39C12',
            'CRITICAL': '#E74C3C',
            'UNKNOWN': '#95A5A6'
        }
        return colors.get(health, '#95A5A6')
    
    def save_dashboard(self, filename: str = "api_monitoring_dashboard.html", 
                      include_plotlyjs: str = 'cdn'):
        """ÎåÄÏãúÎ≥¥ÎìúÎ•º HTML ÌååÏùºÎ°ú Ï†ÄÏû•
        
        Args:
            filename: Ï†ÄÏû•Ìï† ÌååÏùºÎ™Ö
            include_plotlyjs: 'cdn', 'inline', 'directory' Ï§ë ÏÑ†ÌÉù
        """
        if self.dashboard:
            self.dashboard.write_html(
                filename, 
                include_plotlyjs=include_plotlyjs,
                config={'displayModeBar': True, 'displaylogo': False}
            )
            print(f"‚úÖ ÎåÄÏãúÎ≥¥ÎìúÍ∞Ä Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§: {filename}")
        else:
            print("Ï†ÄÏû•Ìï† ÎåÄÏãúÎ≥¥ÎìúÍ∞Ä ÏóÜÏäµÎãàÎã§.")
    
    def show_dashboard(self):
        """ÎåÄÏãúÎ≥¥Îìú ÌëúÏãú"""
        if self.dashboard:
            self.dashboard.show()
        else:
            print("ÌëúÏãúÌï† ÎåÄÏãúÎ≥¥ÎìúÍ∞Ä ÏóÜÏäµÎãàÎã§.")
    
    def create_report(self, save_as: str = "monitoring_report.pdf"):
        """PDF Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± (plotly + kaleido ÌïÑÏöî)"""
        try:
            import kaleido
            
            # Î™®Îì† Ï∞®Ìä∏Î•º Ïù¥ÎØ∏ÏßÄÎ°ú Ï†ÄÏû•
            if self.dashboard:
                self.dashboard.write_image(f"{save_as.replace('.pdf', '')}_dashboard.png", 
                                         width=1600, height=1000, scale=2)
            
            summary_card = self.create_summary_card()
            if summary_card:
                summary_card.write_image(f"{save_as.replace('.pdf', '')}_summary.png",
                                       width=1200, height=400, scale=2)
            
            print(f"‚úÖ Î¶¨Ìè¨Ìä∏ Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.")
            
        except ImportError:
            print("PDF Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±ÏùÑ ÏúÑÌï¥ÏÑúÎäî kaleidoÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§: pip install kaleido")


def main():
    """Î©îÏù∏ Ìï®Ïàò"""
    print("=" * 60)
    print("ÌïúÍµ≠Ìà¨ÏûêÏ¶ùÍ∂å API ÌÜµÍ≥Ñ ÏãúÍ∞ÅÌôî (Plotly Enhanced)")
    print("=" * 60)
    
    # ÏãúÍ∞ÅÌôî Í∞ùÏ≤¥ ÏÉùÏÑ±
    visualizer = PlotlyStatsVisualizer()
    
    # Îç∞Ïù¥ÌÑ∞ Î°úÎìú
    print("\n1. Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ï§ë...")
    visualizer.load_history_data()
    visualizer.load_latest_stats()
    
    if not visualizer.history_data and not visualizer.latest_stats:
        print("ÏãúÍ∞ÅÌôîÌï† Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.")
        return
    
    # ÎåÄÏãúÎ≥¥Îìú ÏÉùÏÑ±
    print("\n2. Ïù∏ÌÑ∞ÎûôÌã∞Î∏å ÎåÄÏãúÎ≥¥Îìú ÏÉùÏÑ± Ï§ë...")
    
    try:
        # Ïã§ÏãúÍ∞Ñ ÎåÄÏãúÎ≥¥Îìú
        dashboard = visualizer.create_realtime_dashboard(update_interval=5000)
        
        # ÏöîÏïΩ Ïπ¥Îìú
        summary_card = visualizer.create_summary_card()
        
        if dashboard:
            print("\nüìä ÎåÄÏãúÎ≥¥Îìú ÏÉùÏÑ± ÏôÑÎ£å!")
            
            # HTMLÎ°ú Ï†ÄÏû•
            visualizer.save_dashboard("api_monitoring_realtime.html")
            
            # ÎåÄÏãúÎ≥¥Îìú ÌëúÏãú
            print("\nÎ∏åÎùºÏö∞Ï†ÄÏóêÏÑú ÎåÄÏãúÎ≥¥ÎìúÎ•º Ïó¨Îäî Ï§ë...")
            visualizer.show_dashboard()
            
            # ÏöîÏïΩ Ïπ¥ÎìúÎèÑ ÌëúÏãú
            if summary_card:
                summary_card.show()
            
            # PDF Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            print("\n3. Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± ÏãúÎèÑ Ï§ë...")
            visualizer.create_report()
        
    except Exception as e:
        print(f"ÎåÄÏãúÎ≥¥Îìú ÏÉùÏÑ± Ï§ë Ïò§Î•ò: {e}")
        import traceback
        traceback.print_exc()
    
    print("\n‚úÖ ÏôÑÎ£å!")
    print("=" * 60)


if __name__ == "__main__":
    main() 